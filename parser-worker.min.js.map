{"version":3,"sources":["src/css-parse.js","src/common-regex.js","src/style-util.js","src/style-transformer.js","entrypoints/parser-worker.js"],"names":["constructor","StyleNode","parse","text","replace","RX$$module$src$css_parse.comments","RX$$module$src$css_parse.port","parseCss","root","length","n","i","l","OPEN_BRACE","p","previous","push","CLOSE_BRACE","node","t","substring","trim","ss","_expandUnicodeEscapes","RX$$module$src$css_parse.multipleSpaces","lastIndexOf","s","indexOf","AT_START","MEDIA_START","types$$module$src$css_parse.MEDIA_RULE","match","RX$$module$src$css_parse.keyframesRule","types$$module$src$css_parse.KEYFRAMES_RULE","split","pop","VAR_START","types$$module$src$css_parse.MIXIN_RULE","types$$module$src$css_parse.STYLE_RULE","r$","r","code","repeat","stringify","preserveProperties","cssText","rules","RX$$module$src$css_parse.customProp","RX$$module$src$css_parse.mixinProp","RX$$module$src$css_parse.mixinApply","RX$$module$src$css_parse.varApply","STYLE_RULE","KEYFRAMES_RULE","MEDIA_RULE","MIXIN_RULE","comments","port","customProp","mixinProp","mixinApply","varApply","keyframesRule","multipleSpaces","MEDIA_MATCH","toCssText","callback","forEachRule","nativeCssVariables","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","type","matchMedia","window","matches","StyleTransformer","css","scope","ext","$jscompDefaultExport","hostScope","rule","isScoped","_transformComplexSelector","self","p$","COMPLEX_SELECTOR_SEP","transformedRule","transformer","call","startsWith","transformedSelector","join","_twiddleNthPlus","selector","NTH","m","inside","stop","isNth","test","inner","SLOTTED_START","HOST","SIMPLE_SELECTOR_SEP","c","info","_transformCompoundSelector","combinator","value","slottedIndex","SLOTTED","_transformHostSelector","_transformSimpleSelector","slotted","SLOTTED_PAREN","paren","DIR_PAREN","before","dir","PSEUDO_PREFIX","HOST_PAREN_FAST","basicSelector","HOST_PAREN_BASIC","typedSelector","HOST_PAREN_TYPED","SIMPLE_SELECTOR_PREFIX","SELECTOR_NO_MATCH","HOST_PAREN_OTHER","RegExp","onmessage","self.onmessage","e","data","is","name","extends","__cssBuild","ast","style","cssBuildType","localName","typeExtension","getAttribute","postMessage","message","scopedStyle"],"mappings":"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","file":"parser-worker.min.js","sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\n/** @unrestricted */\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n    this['end'] = 0;\n    /** @type {StyleNode} */\n    this['previous'] = null;\n    /** @type {StyleNode} */\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n    this['rules'] = null;\n    /** @type {string} */\n    this['parsedCssText'] = '';\n    /** @type {string} */\n    this['cssText'] = '';\n    /** @type {boolean} */\n    this['atRule'] = false;\n    /** @type {number} */\n    this['type'] = 0;\n    /** @type {string} */\n    this['keyframesName'] = '';\n    /** @type {string} */\n    this['selector'] = '';\n    /** @type {string} */\n    this['parsedSelector'] = '';\n  }\n}\n\nexport {StyleNode}\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction lex(text) {\n  let root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      let p = n;\n      let previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = node['parsedSelector'] = node['selector'] = t.trim();\n    node['atRule'] = (s.indexOf(AT_START) === 0);\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] =\n          node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node['rules'];\n  if (r$) {\n    for (let i = 0, l = r$.length, r;\n      (i < l) && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function() {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  let cssText = '';\n  if (node['cssText'] || node['rules']) {\n    let r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r;\n        (i < l) && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties ? node['cssText'] :\n        removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nexport function removeCustomPropAssignment(cssText) {\n  return cssText\n    .replace(RX.customProp, '')\n    .replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText\n    .replace(RX.mixinApply, '')\n    .replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nexport const types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000\n}\n\nconst OPEN_BRACE = '{';\nconst CLOSE_BRACE = '}';\n\n// helper regexp's\nconst RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g\n}\n\nconst VAR_START = '--';\nconst MEDIA_START = '@media';\nconst AT_START = '@';\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nexport const VAR_ASSIGN = /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};{])+)|\\{([^}]*)\\}(?:(?=[;\\s}])|$))/gi;\nexport const MIXIN_MATCH = /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi;\nexport const VAR_CONSUMED = /(--[\\w-]+)\\s*([:,;)]|$)/gi;\nexport const ANIMATION_MATCH = /(animation\\s*:)|(animation-name\\s*:)/;\nexport const MEDIA_MATCH = /@media\\s(.*)/;\nexport const IS_VAR = /^--/;\nexport const BRACKETED = /\\{[^}]*\\}/g;\nexport const HOST_PREFIX = '(?:^|[^.#[:])';\nexport const HOST_SUFFIX = '($|[.:[\\\\s>+~])';\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\n// import {nativeShadow, nativeCssVariables} from './style-settings.js';\nimport {parse, stringify, types, StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\nimport {MEDIA_MATCH} from './common-regex.js';\nimport {processUnscopedStyle, isUnscopedStyle} from './unscoped-style-handler.js';\n\n// TODOD: find a better approach\nconst nativeShadow = false;\nconst nativeCssVariables = true;\n\n/**\n * @param {string|StyleNode} rules\n * @param {function(StyleNode)=} callback\n * @return {string}\n */\nexport function toCssText (rules, callback) {\n  if (!rules) {\n    return '';\n  }\n  if (typeof rules === 'string') {\n    rules = parse(rules);\n  }\n  if (callback) {\n    forEachRule(rules, callback);\n  }\n  return stringify(rules, nativeCssVariables);\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @return {StyleNode}\n */\nexport function rulesForStyle(style) {\n  if (!style['__cssRules'] && style.textContent) {\n    style['__cssRules'] = parse(style.textContent);\n  }\n  return style['__cssRules'] || null;\n}\n\n// Tests if a rule is a keyframes selector, which looks almost exactly\n// like a normal selector but is not (it has nothing to do with scoping\n// for example).\n/**\n * @param {StyleNode} rule\n * @return {boolean}\n */\nexport function isKeyframesSelector(rule) {\n  return Boolean(rule['parent']) &&\n  rule['parent']['type'] === types.KEYFRAMES_RULE;\n}\n\n/**\n * @param {StyleNode} node\n * @param {Function=} styleRuleCallback\n * @param {Function=} keyframesRuleCallback\n * @param {boolean=} onlyActiveRules\n */\nexport function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n  if (!node) {\n    return;\n  }\n  let skipRules = false;\n  let type = node['type'];\n  if (onlyActiveRules) {\n    if (type === types.MEDIA_RULE) {\n      let matchMedia = node['selector'].match(MEDIA_MATCH);\n      if (matchMedia) {\n        // if rule is a non matching @media rule, skip subrules\n        if (!window.matchMedia(matchMedia[1]).matches) {\n          skipRules = true;\n        }\n      }\n    }\n  }\n  if (type === types.STYLE_RULE) {\n    styleRuleCallback(node);\n  } else if (keyframesRuleCallback &&\n    type === types.KEYFRAMES_RULE) {\n    keyframesRuleCallback(node);\n  } else if (type === types.MIXIN_RULE) {\n    skipRules = true;\n  }\n  let r$ = node['rules'];\n  if (r$ && !skipRules) {\n    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {\n      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n    }\n  }\n}\n\n// add a string of cssText to the document.\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @param {Node} target\n * @param {Node} contextNode\n * @return {HTMLStyleElement}\n */\nexport function applyCss(cssText, moniker, target, contextNode) {\n  let style = createScopeStyle(cssText, moniker);\n  applyStyle(style, target, contextNode);\n  return style;\n}\n\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @return {HTMLStyleElement}\n */\nexport function createScopeStyle(cssText, moniker) {\n  let style = /** @type {HTMLStyleElement} */(document.createElement('style'));\n  if (moniker) {\n    style.setAttribute('scope', moniker);\n  }\n  style.textContent = cssText;\n  return style;\n}\n\n/**\n * Track the position of the last added style for placing placeholders\n * @type {Node}\n */\nlet lastHeadApplyNode = null;\n\n// insert a comment node as a styling position placeholder.\n/**\n * @param {string} moniker\n * @return {!Comment}\n */\nexport function applyStylePlaceHolder(moniker) {\n  let placeHolder = document.createComment(' Shady DOM styles for ' +\n    moniker + ' ');\n  let after = lastHeadApplyNode ?\n    lastHeadApplyNode['nextSibling'] : null;\n  let scope = document.head;\n  scope.insertBefore(placeHolder, after || scope.firstChild);\n  lastHeadApplyNode = placeHolder;\n  return placeHolder;\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @param {?Node} target\n * @param {?Node} contextNode\n */\nexport function applyStyle(style, target, contextNode) {\n  target = target || document.head;\n  let after = (contextNode && contextNode.nextSibling) ||\n    target.firstChild;\n  target.insertBefore(style, after);\n  if (!lastHeadApplyNode) {\n    lastHeadApplyNode = style;\n  } else {\n    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode\n    let position = style.compareDocumentPosition(lastHeadApplyNode);\n    if (position === Node.DOCUMENT_POSITION_PRECEDING) {\n      lastHeadApplyNode = style;\n    }\n  }\n}\n\n/**\n * @param {string} buildType\n * @return {boolean}\n */\nexport function isTargetedBuild(buildType) {\n  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';\n}\n\n/**\n * @param {Element} element\n * @return {?string}\n */\nexport function getCssBuildType(element) {\n  return element.getAttribute('css-build');\n}\n\n/**\n * Walk from text[start] matching parens and\n * returns position of the outer end paren\n * @param {string} text\n * @param {number} start\n * @return {number}\n */\nfunction findMatchingParen(text, start) {\n  let level = 0;\n  for (let i=start, l=text.length; i < l; i++) {\n    if (text[i] === '(') {\n      level++;\n    } else if (text[i] === ')') {\n      if (--level === 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {string} str\n * @param {function(string, string, string, string)} callback\n */\nexport function processVariableAndFallback(str, callback) {\n  // find 'var('\n  let start = str.indexOf('var(');\n  if (start === -1) {\n    // no var?, everything is prefix\n    return callback(str, '', '', '');\n  }\n  //${prefix}var(${inner})${suffix}\n  let end = findMatchingParen(str, start + 3);\n  let inner = str.substring(start + 4, end);\n  let prefix = str.substring(0, start);\n  // suffix may have other variables\n  let suffix = processVariableAndFallback(str.substring(end + 1), callback);\n  let comma = inner.indexOf(',');\n  // value and fallback args should be trimmed to match in property lookup\n  if (comma === -1) {\n    // variable, no fallback\n    return callback(prefix, inner.trim(), '', suffix);\n  }\n  // var(${value},${fallback})\n  let value = inner.substring(0, comma).trim();\n  let fallback = inner.substring(comma + 1).trim();\n  return callback(prefix, value, fallback, suffix);\n}\n\n/**\n * @param {Element} element\n * @param {string} value\n */\nexport function setElementClassRaw(element, value) {\n  // use native setAttribute provided by ShadyDOM when setAttribute is patched\n  if (nativeShadow) {\n    element.setAttribute('class', value);\n  } else {\n    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);\n  }\n}\n\n/**\n * @param {Element | {is: string, extends: string}} element\n * @return {{is: string, typeExtension: string}}\n */\nexport function getIsExtends(element) {\n  let localName = element['localName'];\n  let is = '', typeExtension = '';\n  /*\n  NOTE: technically, this can be wrong for certain svg elements\n  with `-` in the name like `<font-face>`\n  */\n  if (localName) {\n    if (localName.indexOf('-') > -1) {\n      is = localName;\n    } else {\n      typeExtension = localName;\n      is = (element.getAttribute && element.getAttribute('is')) || '';\n    }\n  } else {\n    is = /** @type {?} */(element).is;\n    typeExtension = /** @type {?} */(element).extends;\n  }\n  return {is, typeExtension};\n}\n\n/**\n * @param {Element|DocumentFragment} element\n * @return {string}\n */\nexport function gatherStyleText(element) {\n  /** @type {!Array<string>} */\n  const styleTextParts = [];\n  const styles = /** @type {!NodeList<!HTMLStyleElement>} */(element.querySelectorAll('style'));\n  for (let i = 0; i < styles.length; i++) {\n    const style = styles[i];\n    if (isUnscopedStyle(style)) {\n      if (!nativeShadow) {\n        processUnscopedStyle(style);\n        style.parentNode.removeChild(style);\n      }\n    } else {\n      styleTextParts.push(style.textContent);\n      style.parentNode.removeChild(style);\n    }\n  }\n  return styleTextParts.join('').trim();\n}\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\nimport * as StyleUtil from './style-util.js';\n// import {nativeShadow} from './style-settings.js';\n\n/* Transforms ShadowDOM styling into ShadyDOM styling\n\n* scoping:\n\n  * elements in scope get scoping selector class=\"x-foo-scope\"\n  * selectors re-written as follows:\n\n    div button -> div.x-foo-scope button.x-foo-scope\n\n* :host -> scopeName\n\n* :host(...) -> scopeName...\n\n* ::slotted(...) -> scopeName > ...\n\n* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\n* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\n*/\nconst SCOPE_NAME = 'style-scope';\nconst nativeShadow = false; // TODO: find a better approach\n\nclass StyleTransformer {\n  get SCOPE_NAME() {\n    return SCOPE_NAME;\n  }\n  /**\n   * Given a node and scope name, add a scoping class to each node\n   * in the tree. This facilitates transforming css into scoped rules.\n   * @param {?} node\n   * @param {?} scope\n   * @param {?=} shouldRemoveScope\n   */\n  dom(node, scope, shouldRemoveScope) {\n    // one time optimization to skip scoping...\n    if (node['__styleScoped']) {\n      node['__styleScoped'] = null;\n    } else {\n      this._transformDom(node, scope || '', shouldRemoveScope);\n    }\n  }\n\n  _transformDom(node, selector, shouldRemoveScope) {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      this.element(node, selector, shouldRemoveScope);\n    }\n    let c$ = (node.localName === 'template') ?\n      (node.content || node._content).childNodes :\n      node.children || node.childNodes;\n    if (c$) {\n      for (let i=0; i<c$.length; i++) {\n        this._transformDom(c$[i], selector, shouldRemoveScope);\n      }\n    }\n  }\n  /**\n   * @param {?} element\n   * @param {?} scope\n   * @param {?=} shouldRemoveScope\n   */\n  element(element, scope, shouldRemoveScope) {\n    // note: if using classes, we add both the general 'style-scope' class\n    // as well as the specific scope. This enables easy filtering of all\n    // `style-scope` elements\n    if (scope) {\n      // note: svg on IE does not have classList so fallback to class\n      if (element.classList) {\n        if (shouldRemoveScope) {\n          element.classList.remove(SCOPE_NAME);\n          element.classList.remove(scope);\n        } else {\n          element.classList.add(SCOPE_NAME);\n          element.classList.add(scope);\n        }\n      } else if (element.getAttribute) {\n        let c = element.getAttribute(CLASS);\n        if (shouldRemoveScope) {\n          if (c) {\n            let newValue = c.replace(SCOPE_NAME, '').replace(scope, '');\n            StyleUtil.setElementClassRaw(element, newValue);\n          }\n        } else {\n          let newValue = (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope;\n          StyleUtil.setElementClassRaw(element, newValue);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {?} element\n   * @param {?} styleRules\n   * @param {?=} callback\n   */\n  elementStyles(element, styleRules, callback) {\n    let cssBuildType = element['__cssBuild'];\n    // no need to shim selectors if settings.useNativeShadow, also\n    // a shady css build will already have transformed selectors\n    // NOTE: This method may be called as part of static or property shimming.\n    // When there is a targeted build it will not be called for static shimming,\n    // but when the property shim is used it is called and should opt out of\n    // static shimming work when a proper build exists.\n    let cssText = '';\n    if (nativeShadow || cssBuildType === 'shady') {\n      cssText = StyleUtil.toCssText(styleRules, callback);\n    } else {\n      let {is, typeExtension} = StyleUtil.getIsExtends(element);\n      cssText = this.css(styleRules, is, typeExtension, callback) + '\\n\\n';\n    }\n    return cssText.trim();\n  }\n\n  // Given a string of cssText and a scoping string (scope), returns\n  // a string of scoped css where each selector is transformed to include\n  // a class created from the scope. ShadowDOM selectors are also transformed\n  // (e.g. :host) to use the scoping selector.\n  css(rules, scope, ext, callback) {\n    let hostScope = this._calcHostScope(scope, ext);\n\n    let self = this;\n    return StyleUtil.toCssText(rules, function(/** StyleNode */rule) {\n      if (!rule.isScoped) {\n        self.rule(rule, scope, hostScope);\n        rule.isScoped = true;\n      }\n      if (callback) {\n        callback(rule, scope, hostScope);\n      }\n    });\n  }\n\n  _calcElementScope(scope) {\n    if (scope) {\n      return CSS_CLASS_PREFIX + scope;\n    } else {\n      return '';\n    }\n  }\n\n  _calcHostScope(scope, ext) {\n    return ext ? `[is=${scope}]` : scope;\n  }\n\n  rule(rule, scope, hostScope) {\n    this._transformRule(rule, this._transformComplexSelector,\n      scope, hostScope);\n  }\n\n  /**\n   * transforms a css rule to a scoped rule.\n   *\n   * @param {StyleNode} rule\n   * @param {Function} transformer\n   * @param {string=} scope\n   * @param {string=} hostScope\n   */\n  _transformRule(rule, transformer, scope, hostScope) {\n    // NOTE: save transformedSelector for subsequent matching of elements\n    // against selectors (e.g. when calculating style properties)\n    rule['selector'] = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n  }\n\n  /**\n   * @param {StyleNode} rule\n   * @param {Function} transformer\n   * @param {string=} scope\n   * @param {string=} hostScope\n   */\n  _transformRuleCss(rule, transformer, scope, hostScope) {\n    let p$ = rule['selector'].split(COMPLEX_SELECTOR_SEP);\n    // we want to skip transformation of rules that appear in keyframes,\n    // because they are keyframe selectors, not element selectors.\n    if (!StyleUtil.isKeyframesSelector(rule)) {\n      for (let i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n        let transformedRule = transformer.call(this, p, '', hostScope);\n        if (!transformedRule.startsWith(hostScope || ''))\n          transformedRule = `${scope || ''} ${transformedRule}`;\n\n        p$[i] = transformedRule;\n      }\n    }\n    return p$.join(COMPLEX_SELECTOR_SEP);\n  }\n\n  /**\n   * @param {string} selector\n   * @return {string}\n   */\n  _twiddleNthPlus(selector) {\n    return selector.replace(NTH, (m, type, inside) => {\n      if (inside.indexOf('+') > -1) {\n        inside = inside.replace(/\\+/g, '___');\n      } else if (inside.indexOf('___') > -1) {\n        inside = inside.replace(/___/g, '+');\n      }\n      return `:${type}(${inside})`;\n    });\n  }\n\n/**\n * @param {string} selector\n * @param {string} scope\n * @param {string=} hostScope\n */\n  _transformComplexSelector(selector, scope, hostScope) {\n    let stop = false;\n    selector = selector.trim();\n    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n    let isNth = NTH.test(selector);\n    if (isNth) {\n      selector = selector.replace(NTH, (m, type, inner) => `:${type}(${inner.replace(/\\s/g, '')})`)\n      selector = this._twiddleNthPlus(selector);\n    }\n    selector = selector.replace(SLOTTED_START, `${HOST} $1`);\n    selector = selector.replace(SIMPLE_SELECTOR_SEP, (m, c, s) => {\n      if (!stop) {\n        let info = this._transformCompoundSelector(s, c, scope, hostScope);\n        stop = stop || info.stop;\n        c = info.combinator;\n        s = info.value;\n      }\n      return c + s;\n    });\n    if (isNth) {\n      selector = this._twiddleNthPlus(selector);\n    }\n    return selector;\n  }\n\n  _transformCompoundSelector(selector, combinator, scope, hostScope) {\n    // replace :host with host scoping class\n    let slottedIndex = selector.indexOf(SLOTTED);\n    if (selector.indexOf(HOST) >= 0) {\n      selector = this._transformHostSelector(selector, hostScope);\n    // replace other selectors with scoping class\n    } else if (slottedIndex !== 0) {\n      selector = scope ? this._transformSimpleSelector(selector, scope) :\n        selector;\n    }\n    // mark ::slotted() scope jump to replace with descendant selector + arg\n    // also ignore left-side combinator\n    let slotted = false;\n    if (slottedIndex >= 0) {\n      combinator = '';\n      slotted = true;\n    }\n    // process scope jumping selectors up to the scope jump and then stop\n    let stop;\n    if (slotted) {\n      stop = true;\n      if (slotted) {\n        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n        selector = selector.replace(SLOTTED_PAREN, (m, paren) => ` > ${paren}`);\n      }\n    }\n    if (selector.indexOf(':dir') > -1)\n      selector = selector.replace(DIR_PAREN, (m, before, dir) =>\n        `[dir=\"${dir}\"] ${before}, ${before}[dir=\"${dir}\"]`);\n    return {value: selector, combinator, stop};\n  }\n\n  _transformSimpleSelector(selector, scope) {\n    let p$ = selector.split(PSEUDO_PREFIX);\n    p$[0] += scope;\n    return p$.join(PSEUDO_PREFIX);\n  }\n\n  // :host(...) -> scopeName...\n  _transformHostSelector(selector, hostScope) {\n      // ex :host\n      if (!selector.match(HOST_PAREN_FAST))\n        return selector.replace(HOST, hostScope);\n\n      // ex :host(.class)\n      const basicSelector = selector.replace(HOST_PAREN_BASIC, (m, paren) => hostScope + paren);\n      if (basicSelector !== selector)\n        return basicSelector;\n\n      // ex :host(custom-element .class)\n      const typedSelector = selector.replace(HOST_PAREN_TYPED, (m, paren) => paren.split(SIMPLE_SELECTOR_PREFIX)[0] === hostScope ? paren : SELECTOR_NO_MATCH);\n      if (typedSelector !== selector)\n        return typedSelector;\n\n      return selector.replace(HOST_PAREN_OTHER, (m, paren) => hostScope + paren);\n  }\n\n  /**\n   * @param {StyleNode} rule\n   */\n  documentRule(rule) {\n    // reset selector in case this is redone.\n    rule['selector'] = rule['parsedSelector'];\n    this.normalizeRootSelector(rule);\n    this._transformRule(rule, this._transformDocumentSelector);\n  }\n\n  /**\n   * @param {StyleNode} rule\n   */\n  normalizeRootSelector(rule) {\n    if (rule['selector'] === ROOT) {\n      rule['selector'] = 'html';\n    }\n  }\n\n/**\n * @param {string} selector\n */\n  _transformDocumentSelector(selector) {\n    return selector.match(SLOTTED) ?\n      this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) :\n      this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n  }\n}\n\nlet NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\nlet SCOPE_DOC_SELECTOR = `:not(.${SCOPE_NAME})`;\nlet COMPLEX_SELECTOR_SEP = ',';\nlet SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=[])+)/g;\nlet SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\nlet HOST = ':host';\nlet ROOT = ':root';\nlet SLOTTED = '::slotted';\nlet SLOTTED_START = new RegExp(`^(${SLOTTED})`);\n// NOTE: this supports 1 nested () pair for things like\n// :host(:not([selected]), more general support requires\n// parsing which seems like overkill\nlet HOST_PAREN_FAST = /:host\\s*?\\(/;\nlet HOST_PAREN_BASIC = /:host\\s*\\(\\s*([[.:#*][^)(]+?)\\s*\\)/;\nlet HOST_PAREN_TYPED = /:host\\s*\\(\\s*([^[.:#*][^)(]+?)\\s*\\)(.*)/;\nlet HOST_PAREN_OTHER = /:host\\s*\\(\\s*(.+)\\s*\\)/;\n// similar to HOST_PAREN\nlet SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\nlet DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\nlet CSS_CLASS_PREFIX = '.';\nlet PSEUDO_PREFIX = ':';\nlet CLASS = 'class';\nlet SELECTOR_NO_MATCH = 'should_not_match';\n\nexport default new StyleTransformer()\n","import {parse} from '../src/css-parse.js';\nimport StyleTransformer from '../src/style-transformer.js';\n\nself.onmessage = function (e) {\n\tconst {style, name} = e.data;\n  const info = {\n    is: name,\n    extends: null,\n    __cssBuild: '',\n  };\n  const ast = parse(style);\n  const scopedStyle = StyleTransformer.elementStyles(info, ast);\n  const message = {};\n  message['style'] = scopedStyle;\n\tmessage['ast'] = ast;\n\tmessage['name'] = name;\n\n\tself.postMessage(message);\n};\n"]}